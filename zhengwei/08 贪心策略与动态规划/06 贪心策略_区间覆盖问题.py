# -*- coding: utf-8 -*-


'''
1）区间完全覆盖问题
    问题描述：给定一个长度为m的区间，再给出n条线段的起点和终点（注意这里是闭区间），求最少使用多少条线段可以将整个区间完全覆盖
    样例：
    区间长度8，可选的覆盖线段[2,6],[1,4],[3,6],[3,7],[6,8],[2,4],[3,5]
    解题过程:
    1   将每一个区间按照左端点递增顺序排列，拍完序后为[1,4]，[2,4]，[2,6]，[3,5]，[3,6]，[3,7]，[6,8]
    2   设置一个变量表示已经覆盖到的区域。再剩下的线段中找出所有左端点小于等于当前已经覆盖到的区域的右端点的线段中，右端点最大的线段在
        加入，直到已经覆盖全部的区域
    3过程:
        假设第一步加入[1,4]，那么下一步能够选择的有[2,6]，[3,5]，[3,6]，[3,7]，由于7最大，所以下一步选择[3,7]，最后一步只能选择
        [6,8]，这个时候刚好达到了8退出，所选区间为3
    4贪心证明:
        需要最少的线段进行覆盖，那么选取的线段必然要尽量长，而已经覆盖到的区域之前的地方已经无所谓了，（可以理解成所有的可以覆盖的左
        端点都是已经覆盖到的地方），那么真正能够使得线段更长的是右端点，左端点没有太大的意义，所以选择右端点来覆盖

（2）最大不相交覆盖

问题描述:
    给定一个长度为m的区间，再给出n条线段的起点和终点（开区间和闭区间处理的方法是不同，这里以开区间为例），问题是从中选取尽量多的线段
    ，使得每个线段都是独立的，就是不和其它有任何线段有相交的地方

    样例：
    区间长度8，可选的覆盖线段[2,6],[1,4],[3,6],[3,7],[6,8],[2,4],[3,5]
    解题过程:
        对线段的右端点进行升序排序，每加入一个线段，然后选择后面若干个（也有可能是一个）右端点相同的线段，选择左端点最大的那一条，
        如果加入以后不会跟之前的线段产生公共部分，那么就加入，否则就继续判断后面的线
    1排序:将每一个区间按右端点进行递增顺序排列，拍完序后为[1,4]，[2,4]，[3,5]，[2,6]，[3,6]，[3,7]，[6,8]
    2第一步选取[2,4]，发现后面只能加入[6,8],所以区间的个数为2
    贪心证明:因为需要尽量多的独立的线段，所以每个线段都尽可能的小，对于同一右端点，左端点越大，线段长度越小。那么为什么要对右端点进
    行排序呢？如果左端点进行排序，那么右端点是多少并不知道，那么每一条线段都不能对之前所有的线段进行一个总结，那么这就明显不满足贪心
    的最有字结构了。

（3）区间选点问题
    数轴上有n个闭区间[ai,bi]。取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以是同一个）。

    思路(本人思路): 对区间进行右端点的排序,从小在右端点进行标注,即可!!!

    贪心策略：
    按照b1<=b2<=b3…（b相同时按a从大到小）的方式排序排序，从前向后遍历，当遇到没有加入集合的区间时，选取这个区间的右端点b。
    证明：
    为了方便起见，如果区间i内已经有一个点被取到，我们称区间i被满足。
    1、首先考虑区间包含的情况，当小区间被满足时大区间一定被满足。所以我们应当优先选取小区间中的点，从而使大区间不用考虑。
          按照上面的方式排序后，如果出现区间包含的情况，小区间一定在大区间前面。所以此情况下我们会优先选择小区间。
          则此情况下，贪心策略是正确的。
    2、排除情况1后，一定有a1<=a2<=a3……。
          对于区间1来说，显然选择它的右端点是明智的。因为它比前面的点能覆盖更大的范围。
          从而此情况下，贪心策略也是正确的。
'''

'''
    以上只解决第一个问题
'''

# n = 8
#
# nums = [0] * (n + 1)

p_nums = [
    [2, 6], [1, 4], [3, 6], [3, 7], [6, 8], [2, 4], [3, 5]
]

n = len(p_nums)

# 对p_nums区间进行左端点排序

sorted_pnums = sorted(p_nums)

print('sorted pnums is', sorted_pnums)

min_val = sorted_pnums[0][1]  # 获得最小右端点的值
i = 0
res = 1
while i < n:
    # r = []
    v_end = sorted_pnums[i][1]
    j = i + 1

    # 一直循环把那些线段的左端点小于当前右端点的问题给累加消耗掉即可
    while j < n and sorted_pnums[j][0] < v_end:
        j += 1

    i = j

    res += 1

print('res is', res)
